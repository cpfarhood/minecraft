apiVersion: v1
kind: ConfigMap
metadata:
  name: sts-scaler-webhook
data:
  server.py: |
    import os, ssl, json, re
    from http.server import BaseHTTPRequestHandler, HTTPServer
    from urllib.request import Request, urlopen
    from urllib.error import HTTPError, URLError

    TARGET_REPLICAS = int(os.environ.get("TARGET_REPLICAS", "1"))
    SHARED_TOKEN = os.environ["SHARED_TOKEN"]

    # Namespace is derived from the serviceaccount mount (cannot escape it)
    with open("/var/run/secrets/kubernetes.io/serviceaccount/namespace") as f:
      NAMESPACE = f.read().strip()

    TOKEN_PATH = "/var/run/secrets/kubernetes.io/serviceaccount/token"
    CA_PATH = "/var/run/secrets/kubernetes.io/serviceaccount/ca.crt"
    API_HOST = os.environ.get("KUBERNETES_SERVICE_HOST", "kubernetes.default.svc")
    API_PORT = os.environ.get("KUBERNETES_SERVICE_PORT", "443")

    NAME_RE = re.compile(r".+-minecraft$")

    def scale_url(sts):
      return f"https://{API_HOST}:{API_PORT}/apis/apps/v1/namespaces/{NAMESPACE}/statefulsets/{sts}/scale"

    def patch_scale(sts, replicas):
      with open(TOKEN_PATH) as f:
        token = f.read().strip()

      ctx = ssl.create_default_context(cafile=CA_PATH)
      body = json.dumps({"spec": {"replicas": replicas}}).encode()

      req = Request(
        scale_url(sts),
        data=body,
        method="PATCH",
        headers={
          "Authorization": f"Bearer {token}",
          "Content-Type": "application/merge-patch+json",
          "Accept": "application/json",
        },
      )

      with urlopen(req, context=ctx, timeout=5) as r:
        return r.status, r.read().decode()

    class Handler(BaseHTTPRequestHandler):
      def log_message(self, *a): pass

      def auth_ok(self):
        return self.headers.get("Authorization") == f"Bearer {SHARED_TOKEN}"

      def reply(self, code, msg):
        self.send_response(code)
        self.send_header("Content-Type", "text/plain")
        self.end_headers()
        self.wfile.write(msg.encode())

      def do_POST(self):
        if not self.path.startswith("/scale/"):
          self.reply(404, "not found\n"); return

        if not self.auth_ok():
          self.reply(401, "unauthorized\n"); return

        sts = self.path[len("/scale/"):].strip("/")

        if not NAME_RE.fullmatch(sts):
          self.reply(403, "statefulset name must end with -minecraft\n"); return

        try:
          status, body = patch_scale(sts, TARGET_REPLICAS)
          self.reply(200 if 200 <= status < 300 else 502, body)
        except (HTTPError, URLError, Exception) as e:
          self.reply(502, str(e) + "\n")

    if __name__ == "__main__":
      HTTPServer(("0.0.0.0", 8080), Handler).serve_forever()
